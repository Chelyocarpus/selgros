<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wareneingang</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Add DOMPurify -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
  <style>
    /* Custom focus ring for accessibility */
    .focus-ring:focus {
      outline: 2px solid #2563eb;
      outline-offset: 2px;
    }
    /* Visually hidden for screen readers */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-gray-100 via-blue-50 to-gray-200 p-2 sm:p-5">
  <a href="#mainContent" class="sr-only focus:not-sr-only focus:ring-2 focus:ring-blue-600 bg-white text-blue-700 px-3 py-2 rounded shadow z-50 absolute left-2 top-2">Skip to main content</a>
  <main id="mainContent" class="container mx-auto max-w-3xl bg-white rounded-xl shadow-lg p-4 sm:p-8 mt-4 sm:mt-10">
    <header class="flex items-center mb-6">
      <svg class="w-10 h-10 text-blue-600 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path>
      </svg>
      <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">Wareneingang</h1>
    </header>

    <div id="browserWarning" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert" aria-live="assertive">
      <strong class="font-bold">Unsupported Browser! </strong>
      <span class="block sm:inline">This application requires Chrome, Edge, or Opera. Please use a supported browser for full functionality.</span>
    </div>



    <!-- Notification banner with improved structure -->
    <div id="notificationBanner" class="hidden mb-4 rounded relative" role="alert" aria-live="polite">
        <div class="flex items-center p-4">
            <span id="notificationIcon" class="mr-3 text-xl" aria-hidden="true"></span>
            <div class="flex-1">
                <span id="notificationMessage" class="text-sm"></span>
            </div>
            <button onclick="hideNotification()" class="ml-4 text-current opacity-70 hover:opacity-100 focus-ring" aria-label="Close notification" tabindex="0" type="button">
                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" aria-hidden="true">
                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
                <span class="sr-only">Close notification</span>
            </button>
        </div>
    </div>

    <section class="mb-5">
      <h2 class="text-xl font-semibold mb-3">Offene Menge L/A Anomalies</h2>
      <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-4 mb-3">
        <div class="flex-grow">
          <button id="selectFileButton" class="bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus-ring w-full sm:w-auto" aria-label="Select TXT File" type="button">
            <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"></path>
            </svg>
            Select TXT File
          </button>
          <div id="fileInfo" class="mt-2 text-sm text-gray-600 hidden">
            <div class="flex items-center">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20" aria-hidden="true">
                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"></path>
              </svg>
              <span id="fileName">No file selected</span>
            </div>
            <div id="fileDetails" class="ml-5 mt-1 text-xs text-gray-500"></div>
          </div>
        </div>
        <div class="flex flex-col sm:flex-row items-start sm:items-center gap-2">
          <label class="inline-flex items-center cursor-pointer">
            <input type="checkbox" id="autoReload" class="form-checkbox focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" aria-label="Enable auto-reload">
            <span class="ml-2">Auto-reload</span>
          </label>
          <span id="monitorStatus" class="ml-2 px-2 py-1 rounded text-sm" aria-live="polite">⚪ Idle</span>
          <span id="lastChecked" class="text-xs text-gray-500 hidden">Last checked: <span id="lastCheckedTime"></span></span>
        </div>
      </div>
      <button id="processFileButton" class="bg-blue-500 text-white px-4 py-2 rounded focus-ring w-full sm:w-auto" aria-label="Process File" type="button">Process File</button>
    </section>
  </main>

  <!-- Validation Summary wrapper - new separate section -->
  <div id="validationWrapper" class="container mx-auto max-w-4xl px-2 sm:px-6 mt-6 mb-4">
    <div id="validationSummary" class="w-full bg-white rounded-lg shadow border border-gray-200 p-4"></div>
  </div>

  <!-- Table wrapper outside of main for full width -->
  <div id="tableWrapper" class="w-full max-w-full px-2 sm:px-6 lg:px-12 mx-auto mt-2 mb-8">
    <div class="w-full overflow-x-auto rounded-lg shadow bg-white border border-gray-200">
      <div id="output" class="w-full"></div>
    </div>
  </div>

  <script>
    // Configuration object for better maintainability
    const CONFIG = {
      CHECK_INTERVAL: 5000,
      MAX_INTERVAL: 30000,
      BACKOFF_FACTOR: 1.5,
      NOTIFICATION_DURATION: 5000,
      DELIVERED_QUANTITY_COLUMN: 'Offene Menge L/A',
      LOG_LEVELS: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
      },
      CURRENT_LOG_LEVEL: 1 // INFO level by default
    };

    // Logging utility with configurable levels
    const Logger = {
      debug: (message, ...args) => {
        if (CONFIG.CURRENT_LOG_LEVEL <= CONFIG.LOG_LEVELS.DEBUG) {
          console.debug(`[DEBUG] ${message}`, ...args);
        }
      },
      info: (message, ...args) => {
        if (CONFIG.CURRENT_LOG_LEVEL <= CONFIG.LOG_LEVELS.INFO) {
          console.info(`[INFO] ${message}`, ...args);
        }
      },
      warn: (message, ...args) => {
        if (CONFIG.CURRENT_LOG_LEVEL <= CONFIG.LOG_LEVELS.WARN) {
          console.warn(`[WARN] ${message}`, ...args);
        }
      },
      error: (message, ...args) => {
        if (CONFIG.CURRENT_LOG_LEVEL <= CONFIG.LOG_LEVELS.ERROR) {
          console.error(`[ERROR] ${message}`, ...args);
        }
      }
    };

    // Debounced function utility
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };

    // Memoization utility
    const memoize = (fn) => {
      const cache = new Map();
      return (...args) => {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
          return cache.get(key);
        }
        const result = fn(...args);
        cache.set(key, result);
        return result;
      };
    };

    // Browser detection with improved accessibility
    const isSupported = () => {
      return 'showOpenFilePicker' in window;
    };

    // Show warning and disable functionality if unsupported
    if (!isSupported()) {
      const browserWarning = document.getElementById('browserWarning');
      const autoReload = document.getElementById('autoReload');
      const processFileButton = document.getElementById('processFileButton');
      
      if (browserWarning) {
        browserWarning.classList.remove('hidden');
      }
      if (autoReload) {
        autoReload.disabled = true;
      }
      if (processFileButton) {
        processFileButton.disabled = true;
      }
      Logger.error('Browser not supported - missing File System Access API');
    }

    // Application state management
    const AppState = {
      fileHandle: null,
      monitorInterval: null,
      lastModified: null,
      fileChanged: false,
      checkInterval: CONFIG.CHECK_INTERVAL,
      currentFilteredData: [],
      currentHeaders: [],
      currentTargetColumnIndex: -1
    };

    // Error types configuration
    const ERROR_TYPES = {
      FILE_ACCESS: 'FILE_ACCESS',
      FILE_PROCESSING: 'FILE_PROCESSING',
      STORAGE: 'STORAGE',
      MONITORING: 'MONITORING',
      BROWSER_SUPPORT: 'BROWSER_SUPPORT'
    };

    // Notification types and configurations
    const NOTIFICATION_TYPES = {
      INFO: 'INFO',
      SUCCESS: 'SUCCESS',
      WARNING: 'WARNING',
      ERROR: 'ERROR',
      PROCESSING: 'PROCESSING'
    };

    const NOTIFICATION_CONFIGS = {
      [NOTIFICATION_TYPES.INFO]: {
        icon: 'ℹ️',
        classes: 'bg-blue-100 border border-2 border-blue-400 text-blue-700'
      },
      [NOTIFICATION_TYPES.SUCCESS]: {
        icon: '✅',
        classes: 'bg-green-100 border border-2 border-green-400 text-green-700'
      },
      [NOTIFICATION_TYPES.WARNING]: {
        icon: '⚠️',
        classes: 'bg-yellow-100 border border-2 border-yellow-400 text-yellow-700'
      },
      [NOTIFICATION_TYPES.ERROR]: {
        icon: '⚠️',
        classes: 'bg-red-100 border border-2 border-red-400 text-red-700'
      },
      [NOTIFICATION_TYPES.PROCESSING]: {
        icon: '🔄',
        classes: 'bg-blue-100 border border-2 border-blue-400 text-blue-700'
      }
    };

    // Storage utilities
    const StorageUtils = {
      isLocalStorageAvailable() {
        try {
          const test = '__storage_test__';
          localStorage.setItem(test, test);
          localStorage.removeItem(test);
          return true;
        } catch (e) {
          return false;
        }
      }
    };

    // Notification system with improved UX
    const NotificationManager = {
      timeout: null,

      show(message, type = NOTIFICATION_TYPES.INFO, duration = CONFIG.NOTIFICATION_DURATION) {
        const { banner, icon, messageElement } = this.getElements();
        
        // Hide any existing notifications first
        banner.classList.add('hidden');
        
        // Clear previous classes and set new ones
        banner.className = 'mb-4 rounded relative';
        
        // Get config for notification type
        const config = NOTIFICATION_CONFIGS[type] || NOTIFICATION_CONFIGS[NOTIFICATION_TYPES.INFO];
        
        // Apply styling from config
        banner.classList.add(...config.classes.split(' '));
        
        // Set icon and message
        icon.textContent = config.icon || 'ℹ️';
        icon.className = 'mr-3 text-xl';
        messageElement.textContent = message;
        
        // Show the banner
        banner.classList.remove('hidden');

        // Auto-hide if duration is specified
        if (duration > 0) {
          this.clearTimeout();
          this.timeout = setTimeout(() => this.hide(), duration);
        }
      },

      hide() {
        const { banner } = this.getElements();
        banner.classList.add('hidden');
        this.clearTimeout();
      },

      clearTimeout() {
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
      },

      getElements() {
        return {
          banner: document.getElementById('notificationBanner'),
          icon: document.getElementById('notificationIcon'),
          messageElement: document.getElementById('notificationMessage')
        };
      }
    };

    // Legacy function for backward compatibility
    const showNotification = (message, type, duration) => NotificationManager.show(message, type, duration);
    const hideNotification = () => NotificationManager.hide();

    // Error handling with improved logging and user feedback
    const ErrorHandler = {
      handle(error, type, silent = false) {
        // Always log to console with appropriate level
        Logger.error(`[${type}]`, error);

        // Determine user-friendly message
        let userMessage = 'An unexpected error occurred.';
        if (error instanceof Error) {
          const { message } = error;
          switch (type) {
            case ERROR_TYPES.FILE_ACCESS:
              userMessage = `Cannot access file: ${message}`;
              break;
            case ERROR_TYPES.FILE_PROCESSING:
              userMessage = `Error processing file: ${message}`;
              break;
            case ERROR_TYPES.STORAGE:
              userMessage = `Storage error: ${message}`;
              break;
            case ERROR_TYPES.MONITORING:
              userMessage = `File monitoring error: ${message}`;
              break;
            case ERROR_TYPES.BROWSER_SUPPORT:
              userMessage = `Browser compatibility error: ${message}`;
              break;
          }
        } else if (typeof error === 'string') {
          userMessage = error;
        }

        // Show notification unless silent
        if (!silent) {
          NotificationManager.show(userMessage, NOTIFICATION_TYPES.ERROR);
        }

        return { type, message: userMessage, error };
      }
    };

    // State management with improved error handling
    const StateManager = {
      save() {
        if (!AppState.fileHandle || !StorageUtils.isLocalStorageAvailable()) {
          return;
        }
        
        const state = {
          monitoring: !!AppState.monitorInterval,
          lastModified: AppState.lastModified,
          fileName: AppState.fileHandle.name,
          filePath: AppState.fileHandle.name
        };

        try {
          localStorage.setItem('fileProcessor', JSON.stringify(state));
          Logger.debug('State saved successfully');
        } catch (e) {
          const error = ErrorHandler.handle(e, ERROR_TYPES.STORAGE, true);
          
          if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
            try {
              localStorage.removeItem('fileProcessor');
              localStorage.setItem('fileProcessor', JSON.stringify(state));
              Logger.info('Storage cleared and state saved after quota exceeded');
              return;
            } catch (retryError) {
              ErrorHandler.handle(retryError, ERROR_TYPES.STORAGE, true);
            }
          }

          // Show error in status
          UIHelpers.updateMonitorStatus('⚠️ Storage Error', 'bg-red-100');
          setTimeout(() => {
            if (AppState.monitorInterval) {
              UIHelpers.updateMonitorStatus('🟢 Monitoring', 'bg-green-100');
            } else {
              UIHelpers.updateMonitorStatus('⚪ Idle');
            }
          }, 3000);
        }
      },

      async load() {
        // State loading functionality removed - manual file selection only
        Logger.debug('State loading disabled - manual file selection only');
        return;
      }
    };

    // UI Helpers for cleaner code and reusability
    const UIHelpers = {
      updateMonitorStatus(text, bgClass = '') {
        const status = document.getElementById('monitorStatus');
        if (status) {
          status.textContent = text;
          status.className = `ml-2 px-2 py-1 rounded text-sm ${bgClass}`;
        }
      },

      updateFileInfo(file) {
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const details = document.getElementById('fileDetails');
        
        if (fileInfo && fileName && details) {
          fileInfo.classList.remove('hidden');
          fileName.textContent = file.name;
          details.textContent = '';
          
          const lastMod = document.createElement('div');
          lastMod.textContent = `Last modified: ${new Date(file.lastModified).toLocaleString()}`;
          const size = document.createElement('div');
          size.textContent = `Size: ${(file.size / 1024).toFixed(2)} KB`;
          
          details.appendChild(lastMod);
          details.appendChild(size);
        }
      },

      updateTitle(status) {
        const baseTitle = 'Wareneingang';
        document.title = status ? `${baseTitle} (${status})` : baseTitle;
      },

      updateLastChecked() {
        const lastChecked = document.getElementById('lastChecked');
        const lastCheckedTime = document.getElementById('lastCheckedTime');
        
        if (lastChecked && lastCheckedTime) {
          lastChecked.classList.remove('hidden');
          lastCheckedTime.textContent = new Date().toLocaleTimeString();
        }
      }
    };

    // File handling with improved structure
    const FileHandler = {
      async handleSelectedFile(file) {
        try {
          AppState.lastModified = file.lastModified;
          
          UIHelpers.updateFileInfo(file);
          
          const text = await file.text();
          await FileProcessor.processFile(text.trim());
          StateManager.save();
          
          Logger.info('File processed successfully:', file.name);
        } catch (error) {
          ErrorHandler.handle(error, ERROR_TYPES.FILE_PROCESSING);
        }
      }
    };

    // Application initialization with improved structure
    const AppInitializer = {
      async init() {
        if (isSupported()) {
          Logger.info('Browser supported for File System Access API');
          // State loading removed - manual file selection only
        } else {
          Logger.error('Browser not supported');
          // Browser warning already handled in HTML
        }
      }
    };
    
    // Initialize application
    AppInitializer.init();

    // Event handlers with improved structure and error handling
    const EventHandlers = {
      async handleFileSelection() {
        try {
          const handles = await window.showOpenFilePicker({
            types: [{
              description: 'MHTML Files',
              accept: {
                'application/x-mimearchive': ['.mhtml', '.mht'],
                'message/rfc822': ['.mhtml', '.mht']
              }
            }],
            multiple: false,
            startIn: 'downloads'
          });
          
          AppState.fileHandle = handles[0];
          const file = await AppState.fileHandle.getFile();
          await FileHandler.handleSelectedFile(file);
          
        } catch (err) {
          if (err.name !== 'AbortError') {
            ErrorHandler.handle(err, ERROR_TYPES.FILE_ACCESS);
          }
        }
      },

      async handleProcessFile() {
        if (!AppState.fileHandle) {
          NotificationManager.show('Please select a file first!', NOTIFICATION_TYPES.WARNING);
          return;
        }

        try {
          const file = await AppState.fileHandle.getFile();
          const text = await file.text();
          await FileProcessor.processFile(text.trim());
        } catch (err) {
          ErrorHandler.handle(err, ERROR_TYPES.FILE_ACCESS);
        }
      },

      handleAutoReloadToggle(e) {
        if (e.target.checked) {
          if (!AppState.fileHandle) {
            NotificationManager.show('Please select a file first!', NOTIFICATION_TYPES.WARNING);
            e.target.checked = false;
            return;
          }
          UIHelpers.updateMonitorStatus('🟢 Monitoring', 'bg-green-100');
          UIHelpers.updateTitle('🟢 Monitoring');
          AppState.checkInterval = CONFIG.CHECK_INTERVAL;
          MonitoringService.setup();
          StateManager.save();
        } else {
          UIHelpers.updateMonitorStatus('⚪ Idle');
          UIHelpers.updateTitle();
          MonitoringService.cleanup();
          StateManager.save();
        }
      },

      handleBeforeUnload() {
        if (AppState.monitorInterval) {
          StateManager.save();
        }
      }
    };

    // Monitoring service with improved error handling
    const MonitoringService = {
      async checkFileChanges() {
        try {
          if (!AppState.fileHandle) {
            return;
          }
          
          const file = await AppState.fileHandle.getFile();
          
          UIHelpers.updateLastChecked();
          
          if (file.lastModified > AppState.lastModified) {
            AppState.fileChanged = true;
            AppState.lastModified = file.lastModified;
            const text = await file.text();
            await FileProcessor.processFile(text.trim());
            
            // Visual feedback
            UIHelpers.updateMonitorStatus(`🔄 Updated: ${new Date().toLocaleTimeString()}`, 'bg-yellow-100');
            UIHelpers.updateTitle('🔄 Updated');
            
            setTimeout(() => {
              UIHelpers.updateMonitorStatus('🟢 Monitoring', 'bg-green-100');
              UIHelpers.updateTitle('🟢 Monitoring');
            }, 1000);
          } else {
            AppState.fileChanged = false;
          }
        } catch (err) {
          const error = ErrorHandler.handle(err, ERROR_TYPES.MONITORING);
          this.cleanup();
          
          UIHelpers.updateMonitorStatus('⚠️ Error', 'bg-red-100');
          UIHelpers.updateTitle('⚠️ Error');
          
          throw error;
        }
      },

      setup() {
        if (AppState.monitorInterval) {
          clearInterval(AppState.monitorInterval);
        }

        AppState.monitorInterval = setInterval(() => {
          this.checkFileChanges();
          // Increase interval up to maxInterval if no changes detected
          if (!AppState.fileChanged) {
            AppState.checkInterval = Math.min(AppState.checkInterval * CONFIG.BACKOFF_FACTOR, CONFIG.MAX_INTERVAL);
            clearInterval(AppState.monitorInterval);
            AppState.monitorInterval = setInterval(() => this.checkFileChanges(), AppState.checkInterval);
          } else {
            // Reset interval to default when changes are detected
            AppState.checkInterval = CONFIG.CHECK_INTERVAL;
            clearInterval(AppState.monitorInterval);
            AppState.monitorInterval = setInterval(() => this.checkFileChanges(), AppState.checkInterval);
          }
        }, AppState.checkInterval);
      },

      cleanup() {
        clearInterval(AppState.monitorInterval);
        AppState.monitorInterval = null;
        
        // Reset UI state
        UIHelpers.updateMonitorStatus('⚪ Idle');
        const lastChecked = document.getElementById('lastChecked');
        if (lastChecked) {
          lastChecked.classList.add('hidden');
        }
        
        const autoReload = document.getElementById('autoReload');
        if (autoReload) {
          autoReload.checked = false;
        }
        
        const fileInfo = document.getElementById('fileInfo');
        if (fileInfo) {
          fileInfo.classList.add('hidden');
        }
        
        const fileName = document.getElementById('fileName');
        if (fileName) {
          fileName.textContent = 'No file selected';
        }
        
        const fileDetails = document.getElementById('fileDetails');
        if (fileDetails) {
          fileDetails.textContent = '';
        }
        
        // Clear output
        const output = document.getElementById('output');
        if (output) {
          output.textContent = '';
        }
        
        // Reset interval
        AppState.checkInterval = CONFIG.CHECK_INTERVAL;
        
        // Reset file-related state
        AppState.fileHandle = null;
        AppState.lastModified = null;
        AppState.fileChanged = false;
      }
    };

    // Filtering system with improved performance
    const FilterManager = {
      toggleFilter(filterId) {
        const checkbox = document.getElementById(filterId);
        if (checkbox) {
          checkbox.checked = !checkbox.checked;
          this.applyFilters();
        }
      },

      applyFilters() {
        // Use debounce with proper context binding
        if (!this._debouncedApply) {
          this._debouncedApply = debounce(() => {
            const { showZero, showNegative, showPositive } = this.getFilterStates();

            const filteredData = AppState.currentFilteredData.filter(rowData => {
              switch (rowData.type) {
                case 'zero': return showZero;
                case 'negative': return showNegative;
                case 'positive': return showPositive;
                default: return false;
              }
            });

            // Update visible count
            const visibleCountElement = document.getElementById('visibleCount');
            if (visibleCountElement) {
              visibleCountElement.textContent = filteredData.length;
            }

            // Re-render table
            TableRenderer.render(filteredData, AppState.currentHeaders, AppState.currentTargetColumnIndex);
          }, 150);
        }
        this._debouncedApply();
      },

      getFilterStates() {
        const showZero = document.getElementById('showZero')?.checked ?? true;
        const showNegative = document.getElementById('showNegative')?.checked ?? true;
        const showPositive = document.getElementById('showPositive')?.checked ?? true;
        
        return { showZero, showNegative, showPositive };
      },

      initialize() {
        const showZero = document.getElementById('showZero');
        const showNegative = document.getElementById('showNegative');
        const showPositive = document.getElementById('showPositive');
        
        if (showZero) {
          showZero.addEventListener('change', () => this.applyFilters());
        }
        if (showNegative) {
          showNegative.addEventListener('change', () => this.applyFilters());
        }
        if (showPositive) {
          showPositive.addEventListener('change', () => this.applyFilters());
        }
      }
    };

    // Validation summary generator with improved template handling
    const ValidationSummaryGenerator = {
      generate({ totalRows, zeroRows, negativeRows, positiveRows, invalidValues, columnName }) {
        const hasAnomalies = negativeRows > 0 || positiveRows > 0;
        const hasData = zeroRows > 0 || negativeRows > 0 || positiveRows > 0;
        
        return `
          <div class="mb-4">
            <h3 class="font-bold text-lg mb-3">Validation Summary</h3>
            ${this.generateStatsGrid({ totalRows, zeroRows, negativeRows, positiveRows, invalidValues })}
            ${hasData ? this.generateFilterSection({ zeroRows, negativeRows, positiveRows }) : ''}
          </div>
          ${this.generateWarningsAndMessages({ invalidValues, hasAnomalies, columnName })}
        `;
      },

      generateStatsGrid({ totalRows, zeroRows, negativeRows, positiveRows, invalidValues }) {
        return `
          <div class="grid grid-cols-2 sm:grid-cols-5 gap-3 mb-4">
            <div class="bg-gray-100 p-3 rounded shadow-sm">
              <div class="text-sm text-gray-500">Total Rows</div>
              <div class="text-xl font-bold">${totalRows}</div>
            </div>
            <div class="bg-blue-100 p-3 rounded shadow-sm cursor-pointer" onclick="FilterManager.toggleFilter('showZero')" role="button" tabindex="0" aria-label="Toggle zero values filter">
              <div class="text-sm text-blue-500">Normal</div>
              <div class="text-xl font-bold">${zeroRows}</div>
            </div>
            <div class="bg-red-100 p-3 rounded shadow-sm cursor-pointer" onclick="FilterManager.toggleFilter('showNegative')" role="button" tabindex="0" aria-label="Toggle negative values filter">
              <div class="text-sm text-red-500">Falschbuchungen</div>
              <div class="text-xl font-bold">${negativeRows}</div>
            </div>
            <div class="bg-green-100 p-3 rounded shadow-sm cursor-pointer" onclick="FilterManager.toggleFilter('showPositive')" role="button" tabindex="0" aria-label="Toggle positive values filter">
              <div class="text-sm text-green-500">Genullt</div>
              <div class="text-xl font-bold">${positiveRows}</div>
            </div>
            <div class="bg-yellow-100 p-3 rounded shadow-sm">
              <div class="text-sm text-yellow-500">Invalid Values</div>
              <div class="text-xl font-bold">${invalidValues}</div>
            </div>
          </div>
        `;
      },

      generateFilterSection({ zeroRows, negativeRows, positiveRows }) {
        return `
          <div class="border-t pt-4">
            <h4 class="font-semibold mb-3">Filter Values</h4>
            <div class="flex flex-wrap gap-4 items-center">
              <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="showZero" class="form-checkbox text-blue-600 focus:ring-2 focus:ring-blue-500 focus:ring-offset-2" checked aria-label="Show zero values">
                <span class="ml-2 flex items-center">
                  <span class="inline-block w-3 h-3 rounded-full bg-blue-500 mr-2"></span>
                  Normal (${zeroRows})
                </span>
              </label>
              <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="showNegative" class="form-checkbox text-red-600 focus:ring-2 focus:ring-red-500 focus:ring-offset-2" checked aria-label="Show negative values">
                <span class="ml-2 flex items-center">
                  <span class="inline-block w-3 h-3 rounded-full bg-red-500 mr-2"></span>
                  Falschbuchungen (${negativeRows})
                </span>
              </label>
              <label class="inline-flex items-center cursor-pointer">
                <input type="checkbox" id="showPositive" class="form-checkbox text-green-600 focus:ring-2 focus:ring-green-500 focus:ring-offset-2" checked aria-label="Show positive values">
                <span class="ml-2 flex items-center">
                  <span class="inline-block w-3 h-3 rounded-full bg-green-500 mr-2"></span>
                  Genullt (${positiveRows})
                </span>
              </label>
              <div class="ml-auto text-sm text-gray-600">
                Showing <span id="visibleCount">${zeroRows + negativeRows + positiveRows}</span> of <span id="totalCount">${zeroRows + negativeRows + positiveRows}</span> values
              </div>
            </div>
          </div>
        `;
      },

      generateWarningsAndMessages({ invalidValues, hasAnomalies, columnName }) {
        let html = '';
        
        if (invalidValues > 0) {
          html += `
            <div class="bg-yellow-50 border-l-4 border-yellow-400 p-2 text-yellow-700 mt-2">
              <p>Warning: ${invalidValues} invalid numeric values found in '${columnName}' column</p>
            </div>
          `;
        }
        
        if (!hasAnomalies) {
          html += `
            <div class="bg-green-50 border-l-4 border-green-400 p-2 text-green-700 mt-2">
              <p>No Falschbuchungen or Genullt found in '${columnName}' column. All values are normal.</p>
            </div>
          `;
        }
        
        return html;
      }
    };

    // Table rendering with improved performance and accessibility
    const TableRenderer = {
      render(filteredData, headers, targetColumnIndex) {
        const output = document.getElementById('output');
        if (!output) {
          return;
        }

        output.innerHTML = '';

        if (filteredData.length === 0) {
          output.innerHTML = '<p class="text-gray-500 p-4 text-center">No anomalies match the current filter settings.</p>';
          return;
        }

        const table = document.createElement('table');
        table.className = 'min-w-full w-full border-collapse text-sm md:text-base bg-white';
        table.setAttribute('role', 'table');
        table.setAttribute('aria-label', 'Anomaly data table');
        
        table.appendChild(this.createHeader(headers));
        table.appendChild(this.createBody(filteredData, headers, targetColumnIndex));
        
        output.appendChild(table);
      },

      createHeader(headers) {
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.className = 'bg-gray-200';
        headerRow.setAttribute('role', 'row');
        
        // Add empty header for dot column
        const emptyHeader = document.createElement('th');
        emptyHeader.className = 'border border-gray-400 px-2 py-1';
        emptyHeader.setAttribute('scope', 'col');
        emptyHeader.setAttribute('aria-label', 'Row indicator');
        headerRow.appendChild(emptyHeader);
        
        // Add regular headers
        headers.forEach(header => {
          const th = document.createElement('th');
          th.className = 'border border-gray-400 px-2 py-1';
          th.textContent = header;
          th.setAttribute('scope', 'col');
          headerRow.appendChild(th);
        });
        
        thead.appendChild(headerRow);
        return thead;
      },

      createBody(filteredData, headers, targetColumnIndex) {
        const tbody = document.createElement('tbody');
        
        filteredData.forEach((rowData, rowIndex) => {
          const tr = document.createElement('tr');
          tr.setAttribute('role', 'row');
          
          // Add dot at the start of each row
          const dotTd = document.createElement('td');
          const { className, dotHtml } = this.getRowStyle(rowData.type);
          
          tr.className = className;
          dotTd.innerHTML = DOMPurify.sanitize(dotHtml);
          dotTd.className = 'pl-3 py-1';
          dotTd.setAttribute('role', 'cell');
          tr.appendChild(dotTd);
          
          rowData.cells.forEach((cell, index) => {
            const td = document.createElement('td');
            const isNumber = !isNaN(parseFloat(cell.replace(',', '.')));
            let cellClass = `border border-gray-300 px-2 py-1 ${isNumber ? 'text-right' : 'text-left'}`;
            
            // Highlight the quantity column
            if (index === targetColumnIndex) {
              cellClass += this.getHighlightClass(rowData.type);
            }
            
            td.className = cellClass;
            td.textContent = cell;
            td.setAttribute('role', 'cell');
            if (index === targetColumnIndex) {
              td.setAttribute('aria-label', `${headers[index]}: ${cell}`);
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        
        return tbody;
      },

      getRowStyle(type) {
        switch (type) {
          case 'zero':
            return {
              className: 'bg-blue-50 hover:bg-blue-100 transition-colors',
              dotHtml: '<span class="inline-block w-4 h-4 rounded-full bg-blue-500 mr-2" aria-label="Zero value"></span>'
            };
          case 'negative':
            return {
              className: 'bg-red-50 hover:bg-red-100 transition-colors',
              dotHtml: '<span class="inline-block w-4 h-4 rounded-full bg-red-500 mr-2" aria-label="Negative value"></span>'
            };
          case 'positive':
            return {
              className: 'bg-green-50 hover:bg-green-100 transition-colors',
              dotHtml: '<span class="inline-block w-4 h-4 rounded-full bg-green-500 mr-2" aria-label="Positive value"></span>'
            };
          default:
            return {
              className: '',
              dotHtml: '<span class="inline-block w-4 h-4 rounded-full bg-gray-500 mr-2"></span>'
            };
        }
      },

      getHighlightClass(type) {
        switch (type) {
          case 'zero': return ' font-bold text-blue-700';
          case 'negative': return ' font-bold text-red-700';
          case 'positive': return ' font-bold text-green-700';
          default: return '';
        }
      }
    };
    
    // File processor with improved error handling and performance
    const FileProcessor = {
      async processFile(rawData) {
        NotificationManager.show('Processing file...', NOTIFICATION_TYPES.PROCESSING, 0);
        
        try {
          // Clear previous results
          this.clearResults();
          
          // Parse and validate HTML content
          const doc = await this.parseAndValidateHtml(rawData);
          
          // Extract and process table data
          const { headers, targetColumnIndex, stats, filteredData } = this.processTableData(doc);
          
          // Update state
          this.updateApplicationState(filteredData, headers, targetColumnIndex);
          
          // Update UI
          this.updateValidationSummary(stats);
          
          if (stats.negativeRows === 0 && stats.positiveRows === 0) {
            NotificationManager.show('No Falschbuchungen or Genullt found (all values are normal)', NOTIFICATION_TYPES.INFO);
            return;
          }
          
          // Initialize filters and apply them
          FilterManager.initialize();
          FilterManager.applyFilters();
          
          NotificationManager.show(
            `Found ${stats.negativeRows} Falschbuchungen and ${stats.positiveRows} Genullt (${stats.zeroRows} normal values)`,
            NOTIFICATION_TYPES.SUCCESS
          );
          
        } catch (error) {
          this.handleProcessingError(error);
          throw error;
        }
      },

      clearResults() {
        const output = document.getElementById('output');
        const validationSummary = document.getElementById('validationSummary');
        
        if (output) {
          output.innerHTML = '';
        }
        if (validationSummary) {
          validationSummary.innerHTML = '';
        }
      },

      async parseAndValidateHtml(rawData) {
        // Find the HTML content section in MHTML
        const htmlStart = rawData.indexOf('<html');
        
        if (htmlStart === -1) {
          throw new Error('No HTML content found in file. Please ensure this is a valid MHTML file.');
        }
        
        const htmlContent = rawData.substring(htmlStart);
        
        // Sanitize and parse the HTML content
        const sanitizedHtml = DOMPurify.sanitize(htmlContent, {
          WHOLE_DOCUMENT: true,
          RETURN_DOM: false,
          USE_PROFILES: { html: true, svg: false, svgFilters: false }
        });
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(sanitizedHtml, 'text/html');
        
        if (!doc.querySelector('table') && !doc.querySelector('tr')) {
          throw new Error('Invalid file format: No table data found after sanitization');
        }

        return doc;
      },

      processTableData(doc) {
        const rows = doc.querySelectorAll('tr');
        if (!rows.length) {
          throw new Error('No table data found');
        }

        // Extract headers
        const headers = Array.from(rows[0].querySelectorAll('td')).map(td => td.textContent.trim());
        
        // Find required column
        const targetColumnIndex = headers.indexOf(CONFIG.DELIVERED_QUANTITY_COLUMN);
        if (targetColumnIndex === -1) {
          throw new Error(`Required column '${CONFIG.DELIVERED_QUANTITY_COLUMN}' not found in file`);
        }

        // Process data rows and collect stats
        const stats = { totalRows: 0, zeroRows: 0, negativeRows: 0, positiveRows: 0, invalidValues: 0 };
        
        const filteredData = Array.from(rows)
          .slice(1)
          .map(row => {
            stats.totalRows++;
            const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent.trim());
            
            if (!cells[targetColumnIndex]) {
              return null;
            }
            
            const value = parseFloat(cells[targetColumnIndex].replace(',', '.'));
            if (isNaN(value)) {
              stats.invalidValues++;
              return null;
            }
            
            if (value === 0) {
              stats.zeroRows++;
              return { cells, type: 'zero' }; // Include zero values for filtering
            } else if (value < 0) {
              stats.negativeRows++;
              return { cells, type: 'negative' };
            } else if (value > 0) {
              stats.positiveRows++;
              return { cells, type: 'positive' };
            }
            
            return null;
          })
          .filter(row => row !== null);

        return { headers, targetColumnIndex, stats, filteredData };
      },

      updateApplicationState(filteredData, headers, targetColumnIndex) {
        AppState.currentFilteredData = filteredData;
        AppState.currentHeaders = headers;
        AppState.currentTargetColumnIndex = targetColumnIndex;
      },

      updateValidationSummary(stats) {
        const validationSummary = document.getElementById('validationSummary');
        if (validationSummary) {
          validationSummary.innerHTML = DOMPurify.sanitize(
            ValidationSummaryGenerator.generate({
              ...stats,
              columnName: CONFIG.DELIVERED_QUANTITY_COLUMN
            })
          );
        }
      },

      handleProcessingError(error) {
        const validationSummary = document.getElementById('validationSummary');
        if (validationSummary) {
          validationSummary.innerHTML = DOMPurify.sanitize(`
            <div class="bg-red-50 border-l-4 border-red-400 p-4 text-red-700">
              <p class="font-bold">Error Processing File</p>
              <p>${error.message}</p>
            </div>
          `);
        }
        
        NotificationManager.show(`Error processing file: ${error.message}`, NOTIFICATION_TYPES.ERROR);
      }
    };
    // Event listeners setup with improved organization
    const EventListenerSetup = {
      init() {
        this.setupFileSelection();
        this.setupProcessFile();
        this.setupAutoReload();
        this.setupBeforeUnload();
        this.setupKeyboardAccessibility();
      },

      setupFileSelection() {
        const selectFileButton = document.getElementById('selectFileButton');
        if (selectFileButton) {
          selectFileButton.addEventListener('click', EventHandlers.handleFileSelection);
        }
      },

      setupProcessFile() {
        const processFileButton = document.getElementById('processFileButton');
        if (processFileButton) {
          processFileButton.addEventListener('click', EventHandlers.handleProcessFile);
        }
      },

      setupAutoReload() {
        const autoReload = document.getElementById('autoReload');
        if (autoReload) {
          autoReload.addEventListener('change', EventHandlers.handleAutoReloadToggle);
        }
      },

      setupBeforeUnload() {
        window.addEventListener('beforeunload', EventHandlers.handleBeforeUnload);
      },

      setupKeyboardAccessibility() {
        // Add keyboard support for clickable elements
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            const target = e.target;
            if (target.getAttribute('role') === 'button' && target.hasAttribute('tabindex')) {
              e.preventDefault();
              target.click();
            }
          }
        });
      }
    };

    // Legacy function support for backward compatibility
    const toggleFilter = (filterId) => FilterManager.toggleFilter(filterId);

    // Initialize everything when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        EventListenerSetup.init();
        Logger.info('Application initialized successfully');
      });
    } else {
      EventListenerSetup.init();
      Logger.info('Application initialized successfully');
    }
  </script>
</body>
</html>
